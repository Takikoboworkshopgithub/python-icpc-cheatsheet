<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Python 競技プログラミング チートシート (改訂版)</title>
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism-themes/1.9.0/prism-vsc-dark-plus.min.css"
      rel="stylesheet"
    />
    <style>
      /* Base styles for the entire page */
      body {
        font-family: 'Consolas', 'Menlo', 'Monaco', 'Courier New', monospace;
        line-height: 1.6;
        margin: 20px;
        background-color: #1e1e1e; /* VSCode Dark+ background */
        color: #d4d4d4; /* Default text color */
      }

      /* Headings */
      h1,
      h2,
      h3,
      h4 {
        color: #569cd6; /* Blue for main headings */
        margin-top: 30px;
      }
      h1 {
        border-bottom: 2px solid #569cd6;
        padding-bottom: 10px;
      }
      h2 {
        border-bottom: 1px solid #569cd6;
        padding-bottom: 5px;
      }
      h3 {
        color: #ce9178; /* Orange for sub-headings */
      }
      h4 {
        color: #b5cea8; /* Green for deeper sub-headings */
        margin-top: 15px;
        margin-bottom: 5px;
      }
      p {
        color: #d4d4d4;
      }

      /* Section styling */
      .section {
        margin-bottom: 30px;
        padding: 15px;
        background-color: #252526; /* Slightly lighter than body for sections */
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        border-left: 3px solid #007acc; /* VSCode blue border */
      }

      /* Code block styling (Prism.js handles most of this, but for copy button) */
      pre {
        position: relative; /* For positioning the copy button */
        margin-bottom: 15px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        /* Prism.js takes care of background and padding */
      }

      /* Copy button */
      .copy-btn {
        position: absolute;
        top: 5px;
        right: 5px;
        background-color: #007acc; /* VSCode blue */
        color: white;
        border: none;
        padding: 5px 10px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 0.8em;
        opacity: 0.8;
        transition: opacity 0.3s ease, background-color 0.3s ease;
        z-index: 10; /* Ensure button is above code */
      }
      .copy-btn:hover {
        background-color: #0063b2; /* Darker blue on hover */
        opacity: 1;
      }

      /* Table styling */
      table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 15px;
        background-color: #2d2d2d; /* Darker background for tables */
        font-size: 0.9em;
      }
      th,
      td {
        border: 1px solid #3e3e3e; /* Darker border for tables */
        padding: 8px;
        text-align: left;
        color: #d4d4d4;
      }
      th {
        background-color: #3f3f46; /* Header background for tables */
        color: #9cdcfe; /* Light blue for header text */
      }

      /* Details/Summary (folding) styling */
      details {
        margin-bottom: 10px;
        background-color: #2c2c2c; /* Slightly lighter background for details */
        border-radius: 5px;
        padding: 5px 10px;
        border: 1px solid #3e3e3e;
      }
      summary {
        cursor: pointer;
        font-weight: bold;
        color: #9cdcfe; /* Light blue for summary text */
        padding: 5px 0;
        outline: none;
        user-select: none; /* Prevent text selection on click */
      }
      summary:hover {
        color: #569cd6;
      }
      details > summary::-webkit-details-marker {
        /* Remove default marker for custom styling */
        display: none;
      }
      details > summary::before {
        /* Custom arrow/triangle marker */
        content: '▶ ';
        display: inline-block;
        margin-right: 8px;
        font-size: 0.8em;
        transition: transform 0.2s ease;
      }
      details[open] > summary::before {
        transform: rotate(90deg);
      }

      /* Calculation complexity styling */
      .complexity {
        color: #8c8c8c; /* Grey for complexity text */
        font-size: 0.9em;
        margin-top: 5px;
        margin-bottom: 10px;
      }
    </style>
  </head>
  <body>
    <h1>Python 競技プログラミング チートシート (改訂版)</h1>

    <p>
      このチートシートは、競技プログラミングでよく使用されるPythonの関数やスニペットをまとめたものです。VScode風のハイライト、計算量、そして折りたたみ機能を加えました。
    </p>

    <div class="section">
      <h2>1. 基本データ型と操作 (Basic Data Types and Operations)</h2>

      <details open>
        <summary>1.1. `list` (リスト)</summary>
        <table>
          <thead>
            <tr>
              <th>操作</th>
              <th>内容</th>
              <th>計算量</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>`a.append(x)`</td>
              <td>末尾に追加</td>
              <td>O(1)（平均）</td>
            </tr>
            <tr>
              <td>`a.pop()`</td>
              <td>末尾から削除</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>`a.insert(i, x)`</td>
              <td>i番目に挿入</td>
              <td>O(N)</td>
            </tr>
            <tr>
              <td>`a.pop(i)`</td>
              <td>i番目を削除</td>
              <td>O(N)</td>
            </tr>
            <tr>
              <td>`a.remove(x)`</td>
              <td>値xを削除</td>
              <td>O(N)</td>
            </tr>
            <tr>
              <td>`a.sort()`</td>
              <td>昇順に並び替え</td>
              <td>O(N log N)</td>
            </tr>
            <tr>
              <td>`a.reverse()`</td>
              <td>リストの反転</td>
              <td>O(N)</td>
            </tr>
            <tr>
              <td>`x in a`</td>
              <td>存在確認</td>
              <td>O(N)</td>
            </tr>
          </tbody>
        </table>
      </details>

      <details>
        <summary>1.2. `set` (集合)</summary>
        <table>
          <thead>
            <tr>
              <th>操作</th>
              <th>内容</th>
              <th>計算量</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>`s.add(x)`</td>
              <td>要素を追加</td>
              <td>O(1)（平均）</td>
            </tr>
            <tr>
              <td>`s.discard(x)`</td>
              <td>要素を削除（なければ何もしない）</td>
              <td>O(1)（平均）</td>
            </tr>
            <tr>
              <td>`s.remove(x)`</td>
              <td>要素を削除（なければエラー）</td>
              <td>O(1)（平均）</td>
            </tr>
            <tr>
              <td>`x in s`</td>
              <td>存在確認</td>
              <td>O(1)（平均）</td>
            </tr>
            <tr>
              <td>`len(s)`</td>
              <td>要素数取得</td>
              <td>O(1)</td>
            </tr>
          </tbody>
        </table>
      </details>

      <details>
        <summary>1.3. `dict` (辞書)</summary>
        <table>
          <thead>
            <tr>
              <th>操作</th>
              <th>内容</th>
              <th>計算量</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>`d[key] = value`</td>
              <td>追加・更新</td>
              <td>O(1)（平均）</td>
            </tr>
            <tr>
              <td>`d.get(key, 0)`</td>
              <td>存在しない場合のデフォルト取得</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>`del d[key]`</td>
              <td>キーを削除</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>`key in d`</td>
              <td>キー存在確認</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>`len(d)`</td>
              <td>キーの数</td>
              <td>O(1)</td>
            </tr>
          </tbody>
        </table>
      </details>

      <details>
        <summary>1.4. `tuple` (タプル)</summary>
        <table>
          <thead>
            <tr>
              <th>操作</th>
              <th>内容</th>
              <th>計算量</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>`t = (1, 2, 3)`</td>
              <td>宣言</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>`t[i]`</td>
              <td>i番目にアクセス</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>`(x, y) = t`</td>
              <td>アンパック</td>
              <td>O(1)</td>
            </tr>
          </tbody>
        </table>
      </details>

      <details>
        <summary>1.5. `str` (文字列)</summary>
        <table>
          <thead>
            <tr>
              <th>操作</th>
              <th>内容</th>
              <th>計算量</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>`s[i]`</td>
              <td>i文字目アクセス</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>`s[::-1]`</td>
              <td>反転</td>
              <td>O(N)</td>
            </tr>
            <tr>
              <td>`s.split()`</td>
              <td>空白で分割</td>
              <td>O(N)</td>
            </tr>
            <tr>
              <td>`s.replace(a, b)`</td>
              <td>文字列の置換</td>
              <td>O(N)</td>
            </tr>
            <tr>
              <td>`"a" in s`</td>
              <td>部分一致</td>
              <td>O(N)</td>
            </tr>
          </tbody>
        </table>
      </details>

      <details>
        <summary>1.6. `int` (整数)</summary>
        <table>
          <thead>
            <tr>
              <th>操作</th>
              <th>内容</th>
              <th>計算量</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>`str(x)`</td>
              <td>文字列化</td>
              <td>O(D)（D: 桁数）</td>
            </tr>
            <tr>
              <td>`int(s)`</td>
              <td>数値化</td>
              <td>O(D)</td>
            </tr>
            <tr>
              <td>`bin(x)`</td>
              <td>2進数文字列化</td>
              <td>O(log x)</td>
            </tr>
            <tr>
              <td>`divmod(x, y)`</td>
              <td>商と余り同時取得</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>`abs(x)`</td>
              <td>絶対値</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>`pow(x, y, mod)`</td>
              <td>べき乗（mod付き）</td>
              <td>O(log y)</td>
            </tr>
          </tbody>
        </table>
      </details>

      <details>
        <summary>1.7. `float` (浮動小数)</summary>
        <table>
          <thead>
            <tr>
              <th>操作</th>
              <th>内容</th>
              <th>計算量</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>`round(f, k)`</td>
              <td>小数第k位で四捨五入</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>`int(f)`</td>
              <td>小数切り捨て</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>`math.floor(f)`</td>
              <td>小さい整数へ</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>`math.ceil(f)`</td>
              <td>大きい整数へ</td>
              <td>O(1)</td>
            </tr>
          </tbody>
        </table>
      </details>

      <details>
        <summary>1.8. 変換操作 (Conversion Operations)</summary>
        <table>
          <thead>
            <tr>
              <th>目的</th>
              <th>方法</th>
              <th>計算量</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>数 → 文字列</td>
              <td>`str(x)`</td>
              <td>O(D)</td>
            </tr>
            <tr>
              <td>文字列 → 数</td>
              <td>`int(s)`</td>
              <td>O(D)</td>
            </tr>
            <tr>
              <td>リスト → 集合</td>
              <td>`set(lst)`</td>
              <td>O(N)</td>
            </tr>
            <tr>
              <td>集合 → リスト</td>
              <td>`list(set)`</td>
              <td>O(N)</td>
            </tr>
            <tr>
              <td>文字列 → リスト</td>
              <td>`list("abc")`</td>
              <td>O(N)</td>
            </tr>
            <tr>
              <td>リスト → 文字列</td>
              <td>`"".join(list)`</td>
              <td>O(N)</td>
            </tr>
          </tbody>
        </table>
      </details>
    </div>

    <div class="section">
      <h2>2. 標準ライブラリの活用 (Standard Library Utilities)</h2>

      <details open>
        <summary>2.1. `collections` モジュール</summary>
        <details>
          <summary>2.1.1. `defaultdict`</summary>
          <p>キーが存在しないときに自動で初期値を作る辞書。</p>
          <pre><code class="language-python">from collections import defaultdict

dd = defaultdict(int)  # int() → 0が初期値
dd['apple'] += 1      # 存在しなくてもエラーにならず0+1になる
print(dd['apple'])    # 1</code></pre>
          <div class="complexity">計算量: O(1)（平均）</div>
        </details>

        <details>
          <summary>2.1.2. `deque` (両端キュー)</summary>
          <p>両端キュー（高速な両端挿入・削除が可能）。</p>
          <pre><code class="language-python">from collections import deque

dq = deque([1, 2, 3])
dq.append(4)         # 右端に追加
dq.appendleft(0)     # 左端に追加
print(dq)            # deque([0, 1, 2, 3, 4])
dq.pop()             # 右端削除
dq.popleft()         # 左端削除</code></pre>
          <div class="complexity">計算量: `append`, `appendleft`, `pop`, `popleft` は O(1)</div>
        </details>

        <details>
          <summary>2.1.3. `Counter`</summary>
          <p>要素の出現回数を数える辞書。</p>
          <pre><code class="language-python">from collections import Counter

a = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']
counter = Counter(a)
print(counter['apple'])  # 3
print(counter.most_common(2))  # [('apple', 3), ('banana', 2)]</code></pre>
          <div class="complexity">計算量: 初期化は O(N)（Nは要素数）、要素アクセスは O(1)（平均）</div>
        </details>
      </details>

      <details>
        <summary>2.2. `decimal` モジュール</summary>
        <pre><code class="language-python">from decimal import Decimal, ROUND_HALF_UP

# 小数点の丸め処理は my_round 関数を参照</code></pre>
        <div class="complexity">計算量: 処理による</div>
      </details>

      <details>
        <summary>2.3. `functools.lru_cache`</summary>
        <p>再帰関数のメモ化に利用。`memo={}` などで代用可能だが、オーバーロード時に便利。</p>
        <pre><code class="language-python">from functools import lru_cache

@lru_cache(maxsize=None)
def fibo(n):
    if n &lt;= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibo(n - 1) + fibo(n - 2)

# print(fibo(35))</code></pre>
        <div class="complexity">計算量: メモ化により、一度計算した引数での呼び出しは O(1)</div>
      </details>

      <details>
        <summary>2.4. `heapq` モジュール</summary>
        <p>Dijkstra法などで使用。</p>
        <pre><code class="language-python">from heapq import heapify, heappop, heappush
# dijkstra 関数で使用例あり</code></pre>
        <div class="complexity">計算量: `heappush`, `heappop` は O(log K)（Kはヒープの要素数）</div>
      </details>

      <details>
        <summary>2.5. `bisect` モジュール</summary>
        <p>ソート済み配列での挿入位置検索。</p>
        <pre><code class="language-python">from bisect import bisect, bisect_left, bisect_right

a = [1, 2, 4, 4, 5]

# bisect_left：値xを挿入する際、左側の挿入位置（同じ値があれば一番左）
pos_left = bisect_left(a, 4)  # 2

# bisect_right（またはbisect）：値xを挿入する際、右側の挿入位置（同じ値があれば一番右）
pos_right = bisect_right(a, 4)  # 4

print(pos_left, pos_right)

# 使いどころ：ソート済み配列に値を効率的に挿入したり、範囲内の個数を数えたりできる

# 例：配列内の4の個数を数える
count_4 = bisect_right(a, 4) - bisect_left(a, 4)  # 2

print(count_4)</code></pre>
        <div class="complexity">計算量: O(log N)（Nは配列の要素数）</div>
      </details>

      <details>
        <summary>2.6. `itertools` モジュール</summary>
        <details>
          <summary>2.6.1. `accumulate`</summary>
          <pre><code class="language-python">from itertools import accumulate

a = [1, 2, 3, 4, 5]
b = list(accumulate(a)) # [1, 3, 6, 10, 15]</code></pre>
          <div class="complexity">計算量: O(N)（Nはイテラブルの要素数）</div>
        </details>

        <details>
          <summary>2.6.2. `product`</summary>
          <p>複数のイテラブルのデカルト積を計算。</p>
          <pre><code class="language-python">from itertools import product

# 例1: 2進数3桁のすべての組み合わせ
for p in product([0,1],repeat=3):
    print(p)
# 出力:
# (0, 0, 0)
# (0, 0, 1)
# (0, 1, 0)
# (0, 1, 1)
# (1, 0, 0)
# (1, 0, 1)
# (1, 1, 0)
# (1, 1, 1)

# 例2: 色とサイズの組み合わせ
colors = ['red', 'blue']
sizes = ['S', 'M', 'L']

for c, s in product(colors, sizes):
    print(c, s)
# 出力例:
# red S
# red M
# red L
# blue S
# blue M
# blue L</code></pre>
          <div class="complexity">計算量: O(N^k) （Nは各イテラブルの要素数、kはイテラブルの数）</div>
        </details>

        <details>
          <summary>2.6.3. `groupby`</summary>
          <p>連続する要素をグループ化。</p>
          <pre><code class="language-python">from itertools import groupby

# run_length_encoding 関数で使用例あり</code></pre>
          <div class="complexity">計算量: O(N)（Nはイテラブルの要素数）</div>
        </details>
      </details>

      <details>
        <summary>2.7. `string` モジュール</summary>
        <pre><code class="language-python">import string

print(string.ascii_lowercase)   # abcdefghijklmnopqrstuvwxyz
print(string.ascii_uppercase)   # ABCDEFGHIJKLMNOPQRSTUVWXYZ
print(string.ascii_letters)     # abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
print(string.digits)            # 0123456789
print(string.hexdigits)         # 0123456789abcdefABCDEF</code></pre>
        <div class="complexity">計算量: O(1)</div>
      </details>

      <details>
        <summary>2.8. `math` モジュール</summary>
        <details>
          <summary>2.8.1. 丸め関数</summary>
          <table>
            <thead>
              <tr>
                <th>関数</th>
                <th>内容</th>
                <th>計算量</th>
                <th>備考</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>`math.floor(x)`</td>
                <td>$\lfloor x \rfloor$ 下方向に丸める</td>
                <td>O(1)</td>
                <td>`int(x)` との違いに注意</td>
              </tr>
              <tr>
                <td>`math.ceil(x)`</td>
                <td>$\lceil x \rceil$ 上方向に丸める</td>
                <td>O(1)</td>
                <td>切り上げ</td>
              </tr>
              <tr>
                <td>`math.trunc(x)`</td>
                <td>0方向へ丸める</td>
                <td>O(1)</td>
                <td>小数点以下を切り捨て</td>
              </tr>
              <tr>
                <td>`round(x)`</td>
                <td>四捨五入（偶数丸め）</td>
                <td>O(1)</td>
                <td>Pythonの組み込みと同様</td>
              </tr>
            </tbody>
          </table>
        </details>

        <details>
          <summary>2.8.2. 指数・対数関数</summary>
          <table>
            <thead>
              <tr>
                <th>関数</th>
                <th>内容</th>
                <th>計算量</th>
                <th>備考</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>`math.sqrt(x)`</td>
                <td>$\sqrt{x}$（平方根）</td>
                <td>O(1)</td>
                <td>`x ** 0.5` より正確</td>
              </tr>
              <tr>
                <td>`math.pow(x, y)`</td>
                <td>$x^y$（浮動小数）</td>
                <td>O(1)</td>
                <td>`**` より遅く精度高</td>
              </tr>
              <tr>
                <td>`pow(x, y, m)`</td>
                <td>$x^y \pmod m$</td>
                <td>O(log y)</td>
                <td>組み込み関数（整数）</td>
              </tr>
              <tr>
                <td>`math.log(x)`</td>
                <td>$\ln(x)$（自然対数）</td>
                <td>O(1)</td>
                <td>x > 0</td>
              </tr>
              <tr>
                <td>`math.log10(x)`</td>
                <td>$\log_{10}(x)$</td>
                <td>O(1)</td>
                <td>10進対数</td>
              </tr>
              <tr>
                <td>`math.log2(x)`</td>
                <td>$\log_2(x)$</td>
                <td>O(1)</td>
                <td>x のビット長に関係</td>
              </tr>
            </tbody>
          </table>
        </details>

        <details>
          <summary>2.8.3. 整数処理</summary>
          <table>
            <thead>
              <tr>
                <th>関数</th>
                <th>内容</th>
                <th>計算量</th>
                <th>備考</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>`math.gcd(x, y)`</td>
                <td>最大公約数</td>
                <td>O(log min(x,y))</td>
                <td>3項以上は `functools.reduce` と併用</td>
              </tr>
              <tr>
                <td>`math.lcm(x, y)`</td>
                <td>最小公倍数</td>
                <td>O(log min(x,y))</td>
                <td>Python 3.9～</td>
              </tr>
              <tr>
                <td>`math.isqrt(x)`</td>
                <td>$\lfloor \sqrt{x} \rfloor$の整数部分</td>
                <td>O(log x)</td>
                <td>小数を返さない</td>
              </tr>
            </tbody>
          </table>
        </details>
      </details>

      <details>
        <summary>2.9. `sys` モジュール</summary>
        <pre><code class="language-python">import sys

# 再帰関数の呼び出し上限を増やす
sys.setrecursionlimit(10**7)

# 多倍長整数対応 (Python 3.11以降でデフォルト0)
sys.set_int_max_str_digits(0)

# 高速な入力
# input = sys.stdin.readline().rstrip('\n')</code></pre>
        <div class="complexity">計算量: O(1)</div>
      </details>
    </div>

    <div class="section">
      <h2>3. ユーティリティ関数 (Utility Functions)</h2>

      <details open>
        <summary>3.1. 入出力関連 (Input/Output Helpers)</summary>
        <pre><code class="language-python">import sys

# 高速入力の基本設定
def input(): return sys.stdin.readline().rstrip('\n')

# 1つの整数の受け取り
def i(): return int(input())

# スペースで区切られた複数の整数をそれぞれ+nして受け取り
def mi(n = 0): return map(lambda x: int(x)+n, input().split())

# スペースで区切られた複数の整数をそれぞれ+nしてリストで受け取り
def li(n = 0): return list(map(lambda x: int(x)+n, input().split()))

# 変数"ok"がTrueなら"Yes"、Falseなら"No"を出力
def Yes(ok): return print("Yes" if ok else "No")</code></pre>
        <div class="complexity">計算量: 各関数は入力行の長さや要素数に比例（O(L) or O(N)）</div>
      </details>

      <details>
        <summary>3.2. 進数変換 (Base Conversion)</summary>
        <details>
          <summary>3.2.1. 指定された基数に変換 (`base_to`)</summary>
          <pre><code class="language-python">def base_to(num, base):
    """
    指定された基数(base)に数(num)を変換し、桁のリストを返す。
    例: base_to(5, 2) -> ['1', '0', '1'] (2進数)
    """
    if num == 0: return ['0']
    res_list = []
    while num:
        res_list.append(str(num % base))
        num //= base
    return res_list[::-1]</code></pre>
          <div class="complexity">計算量: O(log<sub>base</sub> num)</div>
        </details>

        <details>
          <summary>3.2.2. 指定された基数の数値を10進数に変換 (`base_from`)</summary>
          <pre><code class="language-python">def base_from(s, base):
    """
    指定された基数(base)の文字列(s)またはリスト/タプルを10進数に変換。
    例: base_from('1001', 2) -> 9
        base_from(['1','0','0','1'], 2) -> 9
    """
    if isinstance(s, str):
        return int(s, base)
    elif isinstance(s, (list, tuple)):
        res = 0
        for d in s:
            res = res * base + int(d)
        return res
    else:
        raise TypeError("base_from の引数は str または list/tuple でなければなりません")</code></pre>
          <div class="complexity">計算量: O(D)（Dは桁数）</div>
        </details>
      </details>

      <details>
        <summary>3.3. 数値操作 (Numeric Operations)</summary>
        <details>
          <summary>3.3.1. クランプ (Clamp)</summary>
          <pre><code class="language-python">def clamp(num, smallest, largest):
    """
    numがsmallest以下ならsmallestに、largest以上ならlargestに調整。
    """
    return max(smallest, min(num, largest))</code></pre>
          <div class="complexity">計算量: O(1)</div>
        </details>

        <details>
          <summary>3.3.2. 桁数カウント (Count Digits)</summary>
          <pre><code class="language-python">import math

def count_digit(num):
    """
    整数numの桁数を返す。
    """
    return math.floor(math.log10(num)) + 1 if num > 0 else 1</code></pre>
          <div class="complexity">計算量: O(1) (対数計算)</div>
        </details>

        <details>
          <summary>3.3.3. 階乗と逆元 (Factorial and Inverse) - `precompute_factorials`, `nCr_mod_p`</summary>
          <p>組み合わせ計算などで使用します。事前に `precompute_factorials()` を呼び出す必要があります。</p>
          <pre><code class="language-python"># n! mod p を計算するための関数群
# 組み合わせnCr mod p
# 事前にfact, invfact, invを計算しておく

# max_nは最大値、MODは法
MOD = 10**9 + 7
MAX_N = 2 * 10**5 # 必要に応じて変更

fact = [1] * (MAX_N + 1)
invfact = [1] * (MAX_N + 1)
inv = [1] * (MAX_N + 1)

def precompute_factorials():
    for i in range(2, MAX_N + 1):
        fact[i] = (fact[i-1] * i) % MOD
        inv[i] = MOD - (MOD // i) * inv[MOD % i] % MOD
        invfact[i] = (invfact[i-1] * inv[i]) % MOD

# precompute_factorials() # 必要な場所で一度だけ呼び出す

def nCr_mod_p(n, r):
    if r &lt; 0 or r &gt; n:
        return 0
    return fact[n] * invfact[r] % MOD * invfact[n-r] % MOD</code></pre>
          <div class="complexity">
            `precompute_factorials`: O(MAX_N)<br />
            `nCr_mod_p`: O(1) (前計算後)
          </div>
        </details>

        <details>
          <summary>3.3.4. 繰り返し二乗法 (ModPow)</summary>
          <p>$a^b \pmod{m}$ を高速に計算します。</p>
          <pre><code class="language-python">def mod_pow(a, b, m):
    res = 1
    a %= m
    while b > 0:
        if b % 2 == 1:
            res = (res * a) % m
        a = (a * a) % m
        b //= 2
    return res</code></pre>
          <div class="complexity">計算量: O(log b)</div>
        </details>

        <details>
          <summary>3.3.5. 偶数丸めではない四捨五入 (`my_round`)</summary>
          <pre><code class="language-python">from decimal import Decimal, ROUND_HALF_UP

def my_round(num, d):
    """
    偶数丸めではない四捨五入。dは四捨五入の桁数(ex:0は1の位、2は100の位、-2は0.01の位)
    例:
    print(my_round(127,  0))   # → 130（1の位で四捨五入）
    print(my_round(127,  2))   # → 100（100の位で四捨五入）
    print(my_round(3.146, -2)) # → 3.15（小数第2位）
    print(my_round(3.144, -2)) # → 3.14
    """
    if d &lt;= 0:
        return Decimal(str(num)).quantize(Decimal(str(10**d)), rounding=ROUND_HALF_UP)
    else:
        p = Decimal(str(num)).quantize(Decimal("1E" + str(d)), rounding=ROUND_HALF_UP)
        return p.quantize(Decimal(1))</code></pre>
          <div class="complexity">計算量: 変換する数値の桁数に依存。通常 O(D) (Dは桁数)。</div>
        </details>
      </details>

      <details>
        <summary>3.4. 幾何学 (Geometry)</summary>
        <details>
          <summary>3.4.1. マンハッタン距離 (`Manhattan_distance`)</summary>
          <pre><code class="language-python">import math
from decimal import Decimal

def Manhattan_distance(ax,ay,bx,by):
    """
    座標a(ax,ay)とb(bx,by)の2点間距離（ユークリッド距離）を返す。
    ※ 関数名と内容が一致していません。これはユークリッド距離です。
    """
    return math.sqrt(Decimal((ax-bx)**2 + (ay-by)**2))</code></pre>
          <div class="complexity">計算量: O(1)</div>
          <p class="complexity">
            **注記**: 上記の `Manhattan_distance` 関数は、実際にはユークリッド距離を計算しています。マンハッタン距離は
            $|ax-bx| + |ay-by|$ です。
          </p>
        </details>

        <details>
          <summary>3.4.2. 線分交差判定 (`check_intersection`)</summary>
          <p>数直線上の線分abと線分cdの共通部分があるかどうかチェック。</p>
          <pre><code class="language-python">def check_intersection(a,b,c,d, flg_edge=False):
    """
    数直線上の線分abと線分cdの共通部分があるかどうかチェック。
    flg_edgeがTrueなら端点のみの共有を含む。
    """
    if flg_edge:
        return (max(a,c) &lt;= min(b,d))
    else:
        return (max(a,c) &lt; min(b,d))</code></pre>
          <div class="complexity">計算量: O(1)</div>
        </details>

        <details>
          <summary>3.4.3. 角度180度超判定 (`is_over_180degree`)</summary>
          <p>ベクトルaとベクトルbの角度が180°より大きいか判定。</p>
          <pre><code class="language-python">def is_over_180degree(ax,ay,bx,by):
    """
    ベクトルa(ax,ay)とベクトルb(bx,by)の角度(aから反時計回りに)が180°より大きければ1、180°ちょうどなら2、それ以外は0を返す。
    """
    if ax*by - bx*ay &lt; 0:
        return 1
    elif ax*by - bx*ay == 0:
        return 2
    return 0</code></pre>
          <div class="complexity">計算量: O(1)</div>
        </details>

        <details>
          <summary>3.4.4. 三角形の面積 (`triangle_area`)</summary>
          <pre><code class="language-python">def triangle_area(ax,ay,bx,by,cx,cy):
    """
    3点a(ax,ay),b(bx,by),c(x,cy)からなる三角形の面積を返す。
    """
    return abs((bx-ax)*(cy-ay) - (cx-ax)*(by-ay)) / 2</code></pre>
          <div class="complexity">計算量: O(1)</div>
        </details>
      </details>

      <details>
        <summary>3.5. 配列/リスト操作 (Array/List Operations)</summary>
        <details>
          <summary>
            3.5.1. 最長増加部分列 (Longest Increasing Subsequence - LIS) - `longest_increasing_subsequence`
          </summary>
          <p>計算量 O(N log N)。</p>
          <pre><code class="language-python">from bisect import bisect_left

def longest_increasing_subsequence(A, INF=10**9):
    """
    配列Aの最長増加部分列LISのリストを返す。計算量O(N*logN)。
    例: A = [3, 1, 5, 2, 6, 4, 7]
        LISの例: [1, 2, 4, 7]
    """
    dp = [INF for _ in A]
    b = [-1 for _ in A]
    for i in range(len(A)):
        idx = bisect_left(dp, A[i])
        dp[idx] = A[i]
        b[i] = idx + 1
    l = bisect_left(dp, INF)
    seq = [0 for i in range(l)]
    for i in range(len(A)-1, -1, -1):
        if b[i] == l:
            l -= 1
            seq[l] = A[i]
    return seq</code></pre>
          <div class="complexity">計算量: O(N log N)</div>
        </details>

        <details>
          <summary>3.5.2. 2次元配列の回転 (`list_turn_right`, `list_turn_left`)</summary>
          <pre><code class="language-python">def list_turn_right(l):
    """
    2次元配列lを時計回りに90度回転。
    """
    return list(zip(*l[::-1]))

def list_turn_left(l):
    """
    2次元配列lを反時計回りに90度回転。
    """
    return list(zip(*l))[::-1]</code></pre>
          <div class="complexity">計算量: O(R * C) (Rは行数、Cは列数)</div>
        </details>
      </details>

      <details>
        <summary>3.6. 素数・約数 (Primes and Divisors)</summary>
        <details>
          <summary>3.6.1. 約数列挙 (`divisor`)</summary>
          <pre><code class="language-python">def divisor(x):
    """
    整数xの約数をすべて入れたリストを返す。
    """
    divisors = []
    sqrt_x = int(x ** 0.5)
    for i in range(1, sqrt_x + 1):
        if x % i == 0:
            divisors.append(i)
            if i != x // i:
                divisors.append(x // i)
    return divisors</code></pre>
          <div class="complexity">計算量: O($\sqrt{x}$)</div>
        </details>

        <details>
          <summary>3.6.2. 素数判定 (`is_prime`)</summary>
          <pre><code class="language-python">def is_prime(i):
    """
    iが素数かどうかの判定。
    """
    if i &lt;= 1:
        return False
    for j in range(2, int(i**0.5) + 1):
        if i % j == 0:
            return False
    return True</code></pre>
          <div class="complexity">計算量: O($\sqrt{i}$)</div>
        </details>

        <details>
          <summary>3.6.3. 素因数分解 (`prime_factorize`)</summary>
          <pre><code class="language-python">def prime_factorize(num):
    """
    numを素因数分解したリストを返す。
    """
    factors = []
    while num % 2 == 0:
        factors.append(2)
        num //= 2
    f = 3
    while f * f &lt;= num:
        while num % f == 0:
            factors.append(f)
            num //= f
        f += 2
    if num > 1:
        factors.append(num)
    return factors</code></pre>
          <div class="complexity">計算量: O($\sqrt{num}$)</div>
        </details>

        <details>
          <summary>3.6.4. エラトステネスの篩 (Sieve of Eratosthenes) - `Sieve_of_Eratosthenes`</summary>
          <p>計算量 O(N log log N)。</p>
          <pre><code class="language-python">def Sieve_of_Eratosthenes(num):
    """
    num以下の素数のリストを返す（ソート済みリスト）。計算量O(n*loglogn)。
    """
    res = [True] * (num + 1)
    res[0] = res[1] = False
    for i in range(2, int(num**0.5) + 1):
        if res[i]:
            for j in range(i*i, num + 1, i):
                res[j] = False
    return [i for i in range(num + 1) if res[i]]</code></pre>
          <div class="complexity">計算量: O(num log log num)</div>
        </details>
      </details>

      <details>
        <summary>3.7. その他 (Miscellaneous)</summary>
        <details>
          <summary>3.7.1. グリッド内座標チェック (`check_in_grid`)</summary>
          <pre><code class="language-python">def check_in_grid(height,width,i,j):
    """
    (i,j)が height x widthのグリッドの中の点か確認。
    """
    return ((0 &lt;= i &lt; height) and (0 &lt;= j &lt; width))</code></pre>
          <div class="complexity">計算量: O(1)</div>
        </details>

        <details>
          <summary>3.7.2. パスカルの三角形 (`pascal_triangle`)</summary>
          <p>計算量 O(N^2)。</p>
          <pre><code class="language-python">def pascal_triangle(n):
    """
    n段のパスカルの三角形のリストを返す。計算量O(n**2)。
    """
    res = []
    for i in range(1,n+1):
        if i == 1:
            tmp = [1]
        elif i == 2:
            tmp = [1,1]
        else:
            tmp = []
            for j in range(i):
                if j == 0 or j == i-1:
                    tmp.append(1)
                else:
                    tmp.append(res[i-2][j-1] + res[i-2][j])
        res.append(tmp)
    return res</code></pre>
          <div class="complexity">計算量: O(n^2)</div>
        </details>

        <details>
          <summary>3.7.3. べき乗のリスト (`pow_x`)</summary>
          <pre><code class="language-python">def pow_x(x, n):
    """
    xの0乗～n乗までのリストを返す。
    """
    List_pow = [1]
    for _ in range(n):
        List_pow.append(x * List_pow[-1])
    return List_pow</code></pre>
          <div class="complexity">計算量: O(n)</div>
        </details>

        <details>
          <summary>3.7.4. 連長圧縮 (Run Length Encoding) - `run_length_encoding`</summary>
          <pre><code class="language-python">from itertools import groupby

def run_length_encoding(str_a: str):
    """
    連長圧縮、「ある文字がいくつ連続しているか」を順番に集めたリストを返す。
    例: s = "aaabbaaaccc"
        rle = run_length_encoding(s)
        print(rle)  # [['a', 3], ['b', 2], ['a', 3], ['c', 3]]
    """
    res = [[key,len(list(group))] for key,group in groupby(str_a)]
    return res</code></pre>
          <div class="complexity">計算量: O(N)（Nは文字列の長さ）</div>
        </details>
      </details>
    </div>

    <div class="section">
      <h2>4. 高度なデータ構造とアルゴリズム (Advanced Data Structures and Algorithms)</h2>

      <details open>
        <summary>4.1. Union-Find</summary>
        <p>要素のグループ化や連結判定に用います。</p>
        <pre><code class="language-python">from collections import defaultdict

class UnionFind():
    #「uf = UnionFind(頂点の数)」で初期化
    
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n
 
    def find(self, x): #uf.find(x)
        #要素xが属するグループの根を返す
        if self.parents[x] &lt; 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]
 
    def union(self, x, y): #uf.union(x, y)
        #要素xが属するグループと要素yが属するグループを併合
        x = self.find(x)
        y = self.find(y)
 
        if x == y:
            return
 
        if self.parents[x] &gt; self.parents[y]:
            x, y = y, x
 
        self.parents[x] += self.parents[y]
        self.parents[y] = x
 
    def size(self, x): #uf.size(x)
        #要素xが属するグループのサイズ(要素数)を返す
        return -self.parents[self.find(x)]
 
    def same(self, x, y): #uf.same(x,y)
        #要素x,yが同じグループに属するかどうかを返す
        return self.find(x) == self.find(y)
 
    def members(self, x): #uf.members(x)
        #要素xが属するグループに属する要素をリストで返す
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]
 
    def roots(self): #uf.roots()
        #根となっている要素すべてをリストで返す
        return [i for i, x in enumerate(self.parents) if x &lt; 0]
 
    def group_count(self): #uf.group_count()
        #グループの数を返す
        return len(self.roots())
 
    def all_group_members(self): #uf.all_group_members()
        #{ルート要素 : [そのグループに含まれる要素のリスト], ...}のdefaultdictを返す
        group_members = defaultdict(list)
        for member in range(self.n):
            group_members[self.find(member)].append(member)
        return group_members
 
    def __str__(self):
        return '\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())

# 使用例:
# uf = UnionFind(5)        # 0〜4の5要素
# uf.union(0, 1)           # 0と1を結合
# uf.union(3, 4)           # 3と4を結合
# print(uf.same(0, 1))     # True
# print(uf.same(1, 2))     # False
# print(uf.size(0))        # 2
# print(uf.group_count())  # 3（[0,1], [2], [3,4]）</code></pre>
        <div class="complexity">計算量: ほぼ O($\alpha$(N)) (アッカーマン関数の逆関数、非常に小さい定数とみなせる)</div>
      </details>

      <details>
        <summary>4.2. BinaryTrie</summary>
        <p>ビット単位で数値を管理するトライ木。集合操作やk番目の要素取得、XOR最大値問題などに利用。</p>
        <pre><code class="language-python">class BinaryTrie:
    def __init__(self, max_query=2*10**5, bitlen=30):
        n = max_query * bitlen
        self.nodes = [-1] * (2 * n)
        self.cnt = [0] * n
        self.id = 0
        self.bitlen = bitlen

    def size(self):
        return self.cnt[0]

    def count(self,x): #xの個数
        pt = 0
        for i in range(self.bitlen-1,-1,-1):
            y = x&gt;&gt;i&amp;1
            if self.nodes[2*pt+y] == -1:
                return 0
            pt = self.nodes[2*pt+y]
        return self.cnt[pt]

    def insert(self,x): #xの挿入
        pt = 0
        for i in range(self.bitlen-1,-1,-1):
            y = x&gt;&gt;i&amp;1
            if self.nodes[2*pt+y] == -1:
                self.id += 1
                self.nodes[2*pt+y] = self.id
            self.cnt[pt] += 1
            pt = self.nodes[2*pt+y]
        self.cnt[pt] += 1

    def erase(self,x): #xの削除、xが存在しないときは何もしない
        if self.count(x) == 0:
            return
        pt = 0
        for i in range(self.bitlen-1,-1,-1):
            y = x&gt;&gt;i&amp;1
            self.cnt[pt] -= 1
            pt = self.nodes[2*pt+y]
        self.cnt[pt] -= 1

    def kth_elm(self,x): #昇順x番目の値(1-indexed)
        assert 1 &lt;= x &lt;= self.size()
        pt, ans = 0, 0
        for i in range(self.bitlen-1,-1,-1):
            ans &lt;&lt;= 1
            if self.nodes[2*pt] != -1 and self.cnt[self.nodes[2*pt]] &gt; 0:
                if self.cnt[self.nodes[2*pt]] &gt;= x:
                    pt = self.nodes[2*pt]
                else:
                    x -= self.cnt[self.nodes[2*pt]]
                    pt = self.nodes[2*pt+1]
                    ans += 1
            else:
                pt = self.nodes[2*pt+1]
                ans += 1
        return ans

    def lower_bound(self,x): #x以上の最小要素が昇順何番目か(1-indexed)、x以上の要素がない時はsize+1を返す
        pt, ans = 0, 1
        for i in range(self.bitlen-1,-1,-1):
            if pt == -1: break
            if x&gt;&gt;i&amp;1 and self.nodes[2*pt] != -1:
                ans += self.cnt[self.nodes[2*pt]]
            pt = self.nodes[2*pt+(x&gt;&gt;i&amp;1)]
        return ans

# 使用例:
# bt = BinaryTrie()
# bt.insert(5)     # 集合に 5 を追加
# bt.insert(7)     # 集合に 7 を追加
# bt.insert(5)     # 5 をもう一度追加（multiset）
# bt.insert(9)     # 集合に 9 を追加
# print(bt.count(5))      # → 2
# print(bt.size())        # → 4（全体の要素数）
# print(bt.kth_elm(1))    # → 5（1番目）
# print(bt.lower_bound(6))  # → 3（6以上で最小は 7、3番目）
# bt.erase(5)         # 5を1つ削除（残り1個）
# print(bt.count(5))  # → 1</code></pre>
        <div class="complexity">計算量: 各操作 O(bitlen) (bitlenは数値のビット長、通常30～60程度)</div>
      </details>

      <details>
        <summary>4.3. SortedMultiset</summary>
        <p>ソートされた状態を保つマルチセット（重複を許す集合）。O($\sqrt{N}$) で要素の追加・削除・検索が可能。</p>
        <pre><code class="language-python">from typing import Generic, Iterable, Iterator, TypeVar
from bisect import bisect_left, bisect_right
import math

T = TypeVar('T')

class SortedMultiset(Generic[T]):
    BUCKET_RATIO = 16
    SPLIT_RATIO = 24
    
    def __init__(self, a: Iterable[T] = []) -> None:
        "Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)"
        a = list(a)
        n = self.size = len(a)
        if any(a[i] &gt; a[i + 1] for i in range(n - 1)):
            a.sort()
        num_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))
        self.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]

    def __iter__(self) -&gt; Iterator[T]:
        for i in self.a:
            for j in i: yield j

    def __reversed__(self) -&gt; Iterator[T]:
        for i in reversed(self.a):
            for j in reversed(i): yield j
    
    def __eq__(self, other) -&gt; bool:
        return list(self) == list(other)
    
    def __len__(self) -&gt; int:
        return self.size
    
    def __repr__(self) -&gt; str:
        return "SortedMultiset" + str(self.a)
    
    def __str__(self) -&gt; str:
        s = str(list(self))
        return "{" + s[1 : len(s) - 1] + "}"

    def _position(self, x: T) -&gt; tuple[list[T], int, int]:
        "return the bucket, index of the bucket and position in which x should be. self must not be empty."
        for i, a in enumerate(self.a):
            if x &lt;= a[-1]: break
        return (a, i, bisect_left(a, x))

    def __contains__(self, x: T) -&gt; bool:
        if self.size == 0: return False
        a, _, i = self._position(x)
        return i != len(a) and a[i] == x

    def count(self, x: T) -&gt; int:
        "Count the number of x."
        return self.index_right(x) - self.index(x)

    def add(self, x: T) -&gt; None:
        "Add an element. / O(√N)"
        if self.size == 0:
            self.a = [[x]]
            self.size = 1
            return
        a, b, i = self._position(x)
        a.insert(i, x)
        self.size += 1
        if len(a) &gt; len(self.a) * self.SPLIT_RATIO:
            mid = len(a) &gt;&gt; 1
            self.a[b:b+1] = [a[:mid], a[mid:]]
    
    def _pop(self, a: list[T], b: int, i: int) -&gt; T:
        ans = a.pop(i)
        self.size -= 1
        if not a: del self.a[b]
        return ans

    def discard(self, x: T) -&gt; bool:
        "Remove an element and return True if removed. / O(√N)"
        if self.size == 0: return False
        a, b, i = self._position(x)
        if i == len(a) or a[i] != x: return False
        self._pop(a, b, i)
        return True

    def lt(self, x: T) -&gt; T | None:
        "Find the largest element &lt; x, or None if it doesn't exist."
        for a in reversed(self.a):
            if a[0] &lt; x:
                return a[bisect_left(a, x) - 1]

    def le(self, x: T) -&gt; T | None:
        "Find the largest element &lt;= x, or None if it doesn't exist."
        for a in reversed(self.a):
            if a[0] &lt;= x:
                return a[bisect_right(a, x) - 1]

    def gt(self, x: T) -&gt; T | None:
        "Find the smallest element &gt; x, or None if it doesn't exist."
        for a in self.a:
            if a[-1] &gt; x:
                return a[bisect_right(a, x)]

    def ge(self, x: T) -&gt; T | None:
        "Find the smallest element &gt;= x, or None if it doesn't exist."
        for a in self.a:
            if a[-1] &gt;= x:
                return a[bisect_left(a, x)]
    
    def __getitem__(self, i: int) -&gt; T:
        "Return the i-th element."
        if i &lt; 0:
            for a in reversed(self.a):
                i += len(a)
                if i &gt;= 0: return a[i]
        else:
            for a in self.a:
                if i &lt; len(a): return a[i]
                i -= len(a)
        raise IndexError
    
    def pop(self, i: int = -1) -&gt; T:
        "Pop and return the i-th element."
        if i &lt; 0:
            for b, a in enumerate(reversed(self.a)):
                i += len(a)
                if i &gt;= 0: return self._pop(a, ~b, i)
        else:
            for b, a in enumerate(self.a):
                if i &lt; len(a): return self._pop(a, b, i)
                i -= len(a)
        raise IndexError

    def index(self, x: T) -&gt; int:
        "Count the number of elements &lt; x."
        ans = 0
        for a in self.a:
            if a[-1] &gt;= x:
                return ans + bisect_left(a, x)
            ans += len(a)
        return ans

    def index_right(self, x: T) -&gt; int:
        "Count the number of elements &lt;= x."
        ans = 0
        for a in self.a:
            if a[-1] &gt; x:
                return ans + bisect_right(a, x)
            ans += len(a)
        return ans</code></pre>
        <div class="complexity">
          計算量: 初期化 O(N log N) (ソート済みでなければ)。`add`, `discard` は O($\sqrt{N}$)。`__contains__`, `count`,
          `lt`, `le`, `gt`, `ge`, `__getitem__`, `pop`, `index`, `index_right` は O($\sqrt{N}$)
        </div>
      </details>

      <details>
        <summary>4.4. SortedSet</summary>
        <p>ソートされた状態を保つセット（重複を許さない集合）。O($\sqrt{N}$) で要素の追加・削除・検索が可能。</p>
        <pre><code class="language-python">from typing import Generic, Iterable, Iterator, TypeVar
from bisect import bisect_left, bisect_right
import math

T = TypeVar('T')

class SortedSet(Generic[T]):
    BUCKET_RATIO = 16
    SPLIT_RATIO = 24
    
    def __init__(self, a: Iterable[T] = []) -&gt; None:
        "Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)"
        a = list(a)
        n = len(a)
        if any(a[i] &gt; a[i + 1] for i in range(n - 1)):
            a.sort()
        if any(a[i] &gt;= a[i + 1] for i in range(n - 1)):
            a, b = [], a
            for x in b:
                if not a or a[-1] != x:
                    a.append(x)
        n = self.size = len(a)
        num_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))
        self.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]

    def __iter__(self) -&gt; Iterator[T]:
        for i in self.a:
            for j in i: yield j

    def __reversed__(self) -&gt; Iterator[T]:
        for i in reversed(self.a):
            for j in reversed(i): yield j
    
    def __eq__(self, other) -&gt; bool:
        return list(self) == list(other)
    
    def __len__(self) -&gt; int:
        return self.size
    
    def __repr__(self) -&gt; str:
        return "SortedSet" + str(self.a)
    
    def __str__(self) -&gt; str:
        s = str(list(self))
        return "{" + s[1 : len(s) - 1] + "}"

    def _position(self, x: T) -&gt; tuple[list[T], int, int]:
        "return the bucket, index of the bucket and position in which x should be. self must not be empty."
        for i, a in enumerate(self.a):
            if x &lt;= a[-1]: break
        return (a, i, bisect_left(a, x))

    def __contains__(self, x: T) -&gt; bool:
        if self.size == 0: return False
        a, _, i = self._position(x)
        return i != len(a) and a[i] == x

    def add(self, x: T) -&gt; bool:
        "Add an element and return True if added. / O(√N)"
        if self.size == 0:
            self.a = [[x]]
            self.size = 1
            return True
        a, b, i = self._position(x)
        if i != len(a) and a[i] == x: return False
        a.insert(i, x)
        self.size += 1
        if len(a) &gt; len(self.a) * self.SPLIT_RATIO:
            mid = len(a) &gt;&gt; 1
            self.a[b:b+1] = [a[:mid], a[mid:]]
        return True
    
    def _pop(self, a: list[T], b: int, i: int) -&gt; T:
        ans = a.pop(i)
        self.size -= 1
        if not a: del self.a[b]
        return ans

    def discard(self, x: T) -&gt; bool:
        "Remove an element and return True if removed. / O(√N)"
        if self.size == 0: return False
        a, b, i = self._position(x)
        if i == len(a) or a[i] != x: return False
        self._pop(a, b, i)
        return True
    
    def lt(self, x: T) -&gt; T | None:
        "Find the largest element &lt; x, or None if it doesn't exist."
        for a in reversed(self.a):
            if a[0] &lt; x:
                return a[bisect_left(a, x) - 1]

    def le(self, x: T) -&gt; T | None:
        "Find the largest element &lt;= x, or None if it doesn't exist."
        for a in reversed(self.a):
            if a[0] &lt;= x:
                return a[bisect_right(a, x) - 1]

    def gt(self, x: T) -&gt; T | None:
        "Find the smallest element &gt; x, or None if it doesn't exist."
        for a in self.a:
            if a[-1] &gt; x:
                return a[bisect_right(a, x)]

    def ge(self, x: T) -&gt; T | None:
        "Find the smallest element &gt;= x, or None if it doesn't exist."
        for a in self.a:
            if a[-1] &gt;= x:
                return a[bisect_left(a, x)]
    
    def __getitem__(self, i: int) -&gt; T:
        "Return the i-th element."
        if i &lt; 0:
            for a in reversed(self.a):
                i += len(a)
                if i &gt;= 0: return a[i]
        else:
            for a in self.a:
                if i &lt; len(a): return a[i]
                i -= len(a)
        raise IndexError
    
    def pop(self, i: int = -1) -&gt; T:
        "Pop and return the i-th element."
        if i &lt; 0:
            for b, a in enumerate(reversed(self.a)):
                i += len(a)
                if i &gt;= 0: return self._pop(a, ~b, i)
        else:
            for b, a in enumerate(self.a):
                if i &lt; len(a): return self._pop(a, b, i)
                i -= len(a)
        raise IndexError
    
    def index(self, x: T) -&gt; int:
        "Count the number of elements &lt; x."
        ans = 0
        for a in self.a:
            if a[-1] &gt;= x:
                return ans + bisect_left(a, x)
            ans += len(a)
        return ans

    def index_right(self, x: T) -&gt; int:
        "Count the number of elements &lt;= x."
        ans = 0
        for a in self.a:
            if a[-1] &gt; x:
                return ans + bisect_right(a, x)
            ans += len(a)
        return ans</code></pre>
        <div class="complexity">
          計算量: 初期化 O(N log N) (ソート済みでなければ)。`add`, `discard` は O($\sqrt{N}$)。`__contains__`, `lt`,
          `le`, `gt`, `ge`, `__getitem__`, `pop`, `index`, `index_right` は O($\sqrt{N}$)
        </div>
      </details>

      <details>
        <summary>4.5. セグメントツリー (Segment Tree)</summary>
        <p>区間に対するクエリを高速に処理するデータ構造。結合則を満たす演算であれば適用可能。</p>
        <pre><code class="language-python">class SegTree:
    def __init__(self, op, e, n, v=None):
        self._n = n
        self._op = op
        self._e = e
        self._log = (n - 1).bit_length()
        self._size = 1 &lt;&lt; self._log
        self._d = [self._e()] * (self._size &lt;&lt; 1)
        if v is not None:
            for i in range(self._n):
                self._d[self._size + i] = v[i]
            for i in range(self._size - 1, 0, -1):
                self._d[i] = self._op(self._d[i &lt;&lt; 1], self._d[i &lt;&lt; 1 | 1])
    
    def set(self, p, x):
        p += self._size
        self._d[p] = x
        while p:
            self._d[p &gt;&gt; 1] = self._op(self._d[p], self._d[p ^ 1])
            p &gt;&gt;= 1
    
    def get(self, p):
        return self._d[p + self._size]

    def prod(self, l, r):
        sml, smr = self._e(), self._e()
        l += self._size
        r += self._size
        while l &lt; r:
            if l &amp; 1:
                sml = self._op(sml, self._d[l])
                l += 1
            if r &amp; 1:
                r -= 1
                smr = self._op(self._d[r], smr)
            l &gt;&gt;= 1
            r &gt;&gt;= 1
        return self._op(sml, smr)
    
    def all_prod(self):
        return self._d[1]

# 使用例 (加算の場合):
# st = SegTree(
#     op = lambda a, b: a + b,       # 加算
#     e = lambda: 0,                 # 加算の単位元（0）
#     n = N,                         # 要素数
#     v = A                          # 初期配列（任意）
# )

# 使用例 (XORの場合):
# st = SegTree(
#     op = lambda a, b: a ^ b,       # XOR（ビットごとの排他的論理和）
#     e = lambda: 0,                 # XORの単位元（0）
#     n = N,
#     v = A
# )</code></pre>
        <div class="complexity">
          初期化: O(N)<br />
          `set`: O(log N)<br />
          `get`: O(1)<br />
          `prod`: O(log N)<br />
          `all_prod`: O(1)
        </div>
      </details>

      <details>
        <summary>4.6. ダイクストラ法 (Dijkstra's Algorithm)</summary>
        <p>単一始点最短経路問題に用います。辺の重みが非負である場合に有効です。</p>
        <pre><code class="language-python">import heapq

def dijkstra(edges, num_node):
    """
    経路の表現: [終点, 辺の値]。
    ノードは0からnum_node-1までとする。
    最短距離だけを返す。
    """
    node = [float('inf')] * num_node    #スタート地点以外の値は∞で初期化
    node[0] = 0     #スタートは0で初期化

    node_name = []
    heapq.heappush(node_name, [0, 0]) # (距離, ノード)

    while len(node_name) > 0:
        current_cost, min_point = heapq.heappop(node_name)
        
        if current_cost > node[min_point]: # 既に短いパスが見つかっている場合はスキップ
            continue

        for factor in edges[min_point]:
            goal = factor[0]   #終点
            cost  = factor[1]   #コスト

            #更新条件
            if node[min_point] + cost &lt; node[goal]:
                node[goal] = node[min_point] + cost     #更新
                #ヒープに登録
                heapq.heappush(node_name, [node[min_point] + cost, goal])

    return node

def dijkstra_with_path(edges, num_node, Goal):
    """
    経路の表現: [終点, 辺の値]。
    ノードは0からnum_node-1までとする。
    ゴールまでの最短経路（道順）とコストを返す。
    """
    node = [float('inf')] * num_node    #スタート地点以外の値は∞で初期化
    node[0] = 0     #スタートは0で初期化

    node_name = []
    heapq.heappush(node_name, [0, [0]]) # (コスト, パスリスト)

    while len(node_name) > 0:
        current_cost, min_path = heapq.heappop(node_name)
        last = min_path[-1]

        if current_cost > node[last]: # 既に短いパスが見つかっている場合はスキップ
            continue

        if last == Goal:
            return min_path, node[Goal]  #道順とコストを出力させている
        
        #経路の要素を各変数に格納することで，視覚的に見やすくする
        for factor in edges[last]:
            goal = factor[0]   #終点
            cost  = factor[1]   #コスト

            #更新条件
            if node[last] + cost &lt; node[goal]:
                node[goal] = node[last] + cost     #更新
                #ヒープに登録
                heapq.heappush(node_name, [node[last] + cost, min_path + [goal]])

    return [], float('inf')

# 使用例 (最短距離のみの場合):
# dist = dijkstra(edges, n)
# print(dist[goal])

# 使用例 (ルートを復元する場合):
# path, dist_val = dijkstra_with_path(edges, n, Goal)
# if path:
#     print("→".join(map(str, path)))
#     print(dist_val)
# else:
#     print("No path found")</code></pre>
        <div class="complexity">
          計算量: O((V + E) log V) (Vは頂点数、Eは辺数、優先度キューに格納される要素数を考慮)
        </div>
      </details>
    </div>

    <div class="section">
      <h2>5. 定数・その他 (Constants and Others)</h2>
      <pre><code class="language-python">import string

# 大文字アルファベットのリスト
ALPHABET = list(string.ascii_uppercase) # ["A", "B", "C", ....]

# 小文字アルファベットのリスト
alphabet = list(string.ascii_lowercase) # ["a", "b", "c", ....]

# 1桁の数字のリスト (各要素はstr)
Numbers = list(string.digits) # ["0", "1", "2", ....]

# 座標の移動
# [0:4]で上右下左の4方向
dir_x = [0, 1, 0, -1, 1, 1, -1, -1] # x方向の移動
dir_y = [1, 0, -1, 0, 1, -1, -1, 1] # y方向の移動 (dir_x, dir_yは斜めを含む8方向)
dx_dy = [[0,1], [1,0], [0,-1], [-1,0]] # 上右下左の4方向の移動量 ([dy, dx]または[dx, dy]かは要確認)

# 無限大
INF = float('inf')

# 剰余計算の法 (素数)
MOD1 = 998244353
MOD2 = 10**9 + 7</code></pre>
      <div class="complexity">計算量: O(1) (定数定義)</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
      // Copy button functionality
      document.addEventListener('DOMContentLoaded', () => {
        const codeBlocks = document.querySelectorAll('pre code');
        codeBlocks.forEach((codeBlock) => {
          const pre = codeBlock.parentElement;
          if (!pre || pre.tagName !== 'PRE') return; // Ensure it's a direct child of pre

          const button = document.createElement('button');
          button.className = 'copy-btn';
          button.textContent = 'Copy';
          pre.appendChild(button);

          button.addEventListener('click', () => {
            navigator.clipboard
              .writeText(codeBlock.textContent)
              .then(() => {
                button.textContent = 'Copied!';
                setTimeout(() => {
                  button.textContent = 'Copy';
                }, 2000);
              })
              .catch((err) => {
                console.error('Failed to copy text: ', err);
              });
          });
        });

        // Ensure Prism.js highlights after DOM is loaded and content is there
        // Prism.highlightAll() is usually called automatically, but good to be sure.
        Prism.highlightAll();
      });
    </script>
  </body>
</html>
